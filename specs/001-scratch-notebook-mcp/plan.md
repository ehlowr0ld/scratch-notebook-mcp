# Implementation Plan: Scratch Notebook MCP

**Branch**: `001-scratch-notebook-mcp` | **Date**: 2025-11-16 | **Spec**: `specs/001-scratch-notebook-mcp/spec.md`
**Input**: Feature specification from `specs/001-scratch-notebook-mcp/spec.md` and technical research `specs/scratch-notepad-tool.md`

**Note**: This plan is generated by `/speckit.plan` and must remain aligned with the project constitution and the canonical technical specification in `specs/scratch-notepad-tool.md`. Where they differ, `spec.md` takes precedence.

## Summary

Implement a Python-based MCP server `scratch-notebook` that provides a structured scratch notebook abstraction with:

- Logical scratchpads identified by UUIDs, each containing an ordered list of typed cells (code, JSON, YAML, markdown, text) with optional metadata, per-cell tags, scratchpad tags, a namespace string per tenant, and canonical fields (`title`, `description`, optional `summary`) surfaced in MCP schemas. `scratch_list` intentionally returns only `scratch_id`, `title`, `description`, and `cell_count` for each pad to keep navigation lightweight, while `scratch_read` preserves the full metadata set and will honor an `include_metadata` flag so callers can omit even that when streaming large notebooks.
- Language-aware validation using `jsonschema` (with the `referencing` library for shared schema resolution), `PyYAML`, `syntax-checker`, and `markdown-analysis`, surfaced via a dedicated `scratch-validate` tool, integrated with cell creation/replacement operations, and supporting shared schema registries stored in scratchpad metadata for reuse across multiple cells.
- Configuration system that merges defaults, JSON config files, environment variables, and CLI flags; generates missing config/auth token files (and parent directories) when paths are provided; supports repeated CLI auth-token declarations (`principal:token`) that merge additively with file-based registries; and documents the default-tenant-to-explicit-tenant migration that occurs when auth is enabled after operating without it.
- Schema registry management that stores schemas in scratchpad metadata (UUID id + description + schema), validates schema definitions, and exposes MCP tools for listing, retrieving, and updating schemas per scratchpad.
- Namespace management and tagging features that allow operators to list/create/rename/delete namespaces, filter scratchpads and cells by namespace or tag, and surface scratchpad-level `tags` plus synthesized `cell_tags` in responses.
- Semantic search built on LanceDB vector indices with embeddings generated by `sentence-transformers/all-MiniLM-L6-v2`, including an MCP tool that searches across scratchpads with optional namespace and tag filters and returns ranked results with similarity scores, and a companion tag-listing tool that exposes scratchpad vs cell tag sets.
- Durable persistence backed entirely by LanceDB datasets stored under the configured storage directory, with explicit deletion semantics, capacity limits, and eviction policies (`discard`, `fail`, `preempt`) plus a background sweeper; no JSON flat files remain.
- Multi-transport access (stdio MCP, HTTP + SSE) with configurable listeners, optional auth, structured logging to stdout/stderr, and an optional Prometheus metrics endpoint.

The implementation must comply with all functional and non-functional requirements in `spec.md`, and the schemas and tool contracts defined in `scratch-notepad-tool.md` must be treated as authoritative for data shapes and protocol behavior.

## Technical Context

**Language/Version**: Python 3.11+ (asyncio-first, non-blocking event loop)
**Primary Dependencies**:
- `fastmcp` for MCP server scaffolding and tool exposure
- `jsonschema` plus `referencing` for JSON Schema validation and shared-schema resolution
- `PyYAML` for YAML parsing
- `syntax-checker` for multi-language code syntax diagnostics
- `markdown-analysis` for markdown analysis
- `lancedb` for embedded structured and vector storage
- `sentence-transformers` (default: `all-MiniLM-L6-v2`) for semantic search embeddings
**Storage**: LanceDB datasets located beneath the configured storage directory, providing structured columns for scratchpad metadata, namespaces, tags, schema registry entries, and vector columns for semantic search. No ad hoc JSON files remain; all CRUD and query operations use LanceDB's filtering and vector search APIs.
**Testing**: `pytest` with separate unit, integration, and contract test layers; contract tests will exercise MCP tools and (optionally) HTTP/SSE endpoints using example payloads that conform to the schemas in `scratch-notepad-tool.md`.
**Target Platform**: Linux (development on local machines, deployment as a local MCP tool or small service); must run reliably in typical dev containers and local environments.
**Project Type**: Single service/library project (MCP server package) with CLI entrypoint for local runs and testing.
**Performance Goals**:
- Typical scratch operations (create/read/append/replace/delete/list) complete in under 500 ms for normal-sized scratchpads.
- Validation must be fast enough for interactive use on small to medium documents; heavy validation is bounded by a configurable overall request timeout.
**Constraints**:
- Non-blocking async: do not block the event loop; offload any CPU-heavy validation or file I/O appropriately.
- Security-first: safe defaults for listeners (localhost), optional auth for remote deployments, and strict isolation of scratchpads between authenticated principals when auth is enabled.
- Storage must be durable across normal restarts and safe against trivial brute-force enumeration of ids.
- Operators may provide multiple auth tokens via repeated CLI options; these merge with optional JSON token registries and are persisted when the server materializes config/token files on first run.
**Scale/Scope**:
- Intended for single-user or small multi-tenant use with up to thousands of scratchpads and thousands of cells per scratchpad; not a large-scale multi-tenant data store.

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- **Exploration-First Development (I)**:
  - This plan assumes actual implementation will begin only after reviewing `spec.md`, `scratch-notepad-tool.md`, `constitution.md`, and the selected Python dependencies' docs (`fastmcp`, `jsonschema`, `syntax-checker`, `markdown-analysis`, `PyYAML`).
  - The research and data-model documents created for this feature will serve as the living record of that exploration.

- **Security-First Design (III)**:
  - Scratchpads are identified by UUIDs and must not be discoverable by brute-force id guessing; when auth is enabled, all operations are scoped to the authenticated principal.
  - HTTP/SSE listeners default to `127.0.0.1` with optional bearer-token auth for remote use; no anonymous-wide exposure is allowed by default.
  - Validation tools are invoked in a controlled, sandboxed manner without executing user code.

- **Non-Blocking Async (IV)**:
  - The MCP server must use asyncio end-to-end; no `time.sleep()` or other blocking calls in async contexts.
  - File I/O and any CPU-heavy validation must be structured so the event loop remains responsive, either via async I/O or appropriate offloading.

- **Architectural Boundaries (VII)**:
  - The scratch notebook MCP server will be implemented as a cohesive Python package with clear module boundaries (storage, validation, transports, config), avoiding parallel architectures for the same concern.
  - The MCP tools and HTTP/SSE APIs are treated as the single integration surface; internal storage/layout details remain encapsulated.

At this stage, no constitution violations are anticipated. Any later need for additional complexity (for example, pluggable storage backends) must be justified and recorded in the Complexity Tracking section.

## Project Structure

### Documentation (this feature)

```text
specs/001-scratch-notebook-mcp/
├── plan.md              # This file: implementation phases and architectural plan
├── research.md          # Phase 0: exploration notes and key technical decisions
├── data-model.md        # Phase 1: consolidated data and schema model
├── quickstart.md        # Phase 1: how to run, configure, and use the server
├── contracts/
│   ├── mcp-tools.md     # MCP tool contracts (scratch_* tools)
│   └── transports-and-config.md  # HTTP/SSE endpoints, config surface, error codes
└── tasks.md             # Phase 2: detailed implementation tasks (/speckit.tasks)
```

### Source Code (repository root)

```text
.venv/                            # local virtual environment (created via uv venv .venv --python=3.12 --seed)
requirements.txt                  # (optional) runtime dependency pinning, aligned with pyproject.toml
requirements-dev.txt              # dev/test/lint dependencies (pytest, ruff, mypy, etc.)

scratch_notebook/                 # Python package root (editable install / local dev)
├── __init__.py
├── server.py                     # fastmcp server wiring and tool registration
├── config.py                     # configuration loading (CLI args, env, JSON file)
├── models.py                     # in-memory/domain models (Scratchpad, Cell, ValidationResult)
├── storage.py                    # LanceDB-backed persistence layer for scratchpads, namespaces, schemas, embeddings
├── search.py                     # Semantic search orchestration (embedding generation + LanceDB vector queries)
├── namespaces.py                 # Namespace orchestration (list/create/rename/delete)
├── validation.py                 # orchestration of jsonschema, PyYAML, syntax-checker, markdown-analysis
├── eviction.py                   # capacity limit, discard/fail/preempt policies and sweeper
├── transports/
│   ├── __init__.py
│   ├── stdio.py                  # stdio MCP entrypoint
│   ├── http.py                   # HTTP + SSE listener (shared host/port/socket)
│   └── metrics.py                # optional /metrics endpoint (Prometheus format)
├── auth.py                       # optional bearer-token auth and principal scoping
├── logging.py                    # structured stdout/stderr logging helpers
└── errors.py                     # central error code definitions and helpers

tests/
├── unit/
│   ├── test_models.py
│   ├── test_storage.py
│   ├── test_validation.py
│   ├── test_eviction.py
│   ├── test_namespaces.py
│   ├── test_search.py
│   ├── test_canonical_metadata.py
│   ├── test_tag_listing.py
│   └── test_config.py
├── integration/
│   ├── test_mcp_tools.py         # end-to-end via fastmcp tools
│   └── test_http_sse.py          # HTTP/SSE endpoints and auth behavior
└── contract/
    └── test_schemas_and_examples.py  # request/response examples vs schemas

pyproject.toml or setup.cfg       # packaging and dependency metadata
README.md                         # top-level overview (may reference quickstart.md)
```

**Structure Decision**:
Use a single Python package `scratch_notebook` within this repository to implement the MCP server, keeping storage, validation, transports, and configuration concerns in clearly separated modules. Tests are organized into unit, integration, and contract suites to enforce both internal correctness and adherence to the schemas and contracts specified in `scratch-notepad-tool.md` and the feature spec.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|--------------------------------------|
| *(none identified at planning time)* | N/A | N/A |

## 4. Storage And Persistence

### 4.1 Storage Directory

- On startup the server resolves a `storage_dir` (via config/CLI/env). If the directory does not exist it is created recursively; otherwise startup fails with `CONFIG_ERROR`.
- Every LanceDB dataset and auxiliary file lives beneath this directory. No other persistent location is touched.

### 4.2 LanceDB Layout

- Use a dedicated LanceDB database file (for example `<storage_dir>/scratchpads.lance`) opened in embedded mode.
- Recommended tables/collections:
  - `scratchpads`: columns `scratch_id` (UUID, primary key), `tenant_id`, `namespace`, `tags` (list<string>), `metadata` (struct), `cells` (nested struct array), `schemas` (array of structs), `updated_at`, `created_at`.
  - `cells`: optional normalized table keyed by `(scratch_id, cell_id)` to speed per-cell queries when scratchpads become large. Stores `index`, `language`, `content`, `tags`, `validate` flag, and derived metadata.
  - `embeddings`: vector column referencing `(scratch_id, cell_id)` plus metadata (namespace, tags, top-level text snippet).
  - `namespaces`: optional helper table tracking namespace strings per tenant with creation timestamps when namespaces exist without scratchpads.
- LanceDB supports schema evolution; migrations must be handled carefully (for example using transactional `alter` operations).

### 4.3 Access Patterns

- CRUD operations use LanceDB filters (SQL/DataFusion expression syntax) rather than loading entire datasets into memory. Typical patterns:
  - Read scratchpad: `SELECT * FROM scratchpads WHERE scratch_id = ? AND tenant_id = ?`.
  - List scratchpads with filters: `SELECT scratch_id, namespace, tags, metadata FROM scratchpads WHERE tenant_id = ? AND namespace IN (...) AND list_has_any(tags, ?)`.
  - Namespace listing: `SELECT DISTINCT namespace FROM scratchpads WHERE tenant_id = ?` UNION `SELECT namespace FROM namespaces WHERE tenant_id = ?`.
- Updates wrap multiple tables (for example scratchpad + embeddings) in a logical transaction: write to LanceDB using append+delete semantics ensuring atomicity via staged writes.

### 4.4 Durability And Crash Recovery

- LanceDB writes are appended then compacted; after each mutation the implementation MUST call `table.commit()` (or equivalent) to guarantee durability before responding.
- Crash recovery simply reopens the LanceDB dataset; no replay logs are required beyond LanceDB internals.

### 4.5 Ids And Uniqueness

- Primary keys (`scratch_id`, `cell_id`, `namespace`) are enforced at the LanceDB level. Attempted duplicates raise an error that MUST be turned into `INVALID_ID` for clients.
- Namespace names are unique per tenant; normalization/validation (trim whitespace, forbid empty strings) happens before insertion.

## Phase 9: Scalability & Precision Optimization

**Goal**: Improve performance and accuracy for large-scale (>10k pads) and high-cardinality (many namespaces) deployments by leveraging native LanceDB indexing and pre-filtering. (See `specs/001-scratch-notebook-mcp/research.md` Section 5 for technical implementation details and code examples).

### Key Improvements

1.  **Scalable Default Tenant Migration**:
    *   **Issue**: Currently performs a full table scan O(N) at startup.
    *   **Resolution**: Create a scalar index on `tenant_id` and use LanceDB's `search()` API with a filter predicate (`tenant_id = 'default'`) to retrieve only relevant rows (O(log N)).
2.  **Native Vector Search Pre-filtering**:
    *   **Issue**: Post-filtering in Python can return zero results if top K global matches are in excluded namespaces.
    *   **Resolution**: Push `namespace IN (...)` predicates down to LanceDB using the `prefilter=True` argument (or SQL `where` clause). This ensures the limit applies only to valid candidates.

### Testing Strategy

*   **Migration Test**: Verify that `migrate_default_tenant` correctly identifies and updates only `default` tenant rows without touching others, even in a mixed-tenant database.
*   **Pre-filtering Test**: Seed a database with highly similar documents in Namespace A and Namespace B. Query with a filter for Namespace B. Verify that the system returns K results from Namespace B, even if Namespace A has "better" raw vector matches.

## Phase 10: One-Shot Creation & Context Efficiency

**Goal**: Streamline agent workflows by allowing a scratchpad to be fully initialized in one call, while optimizing response payloads to prevent context window exhaustion.

### Key Improvements

1.  **Atomic One-Shot Creation**:
    *   `scratch_create` accepts an optional `cells` array.
    *   Storage layer persists the pad and all initial cells in one transaction.
    *   Failure in any cell definition aborts the entire creation (no partial pads).

2.  **Context-Efficient Responses**:
    *   Write operations (`create`, `append`, `replace`) return **structural** confirmation (IDs, indices, validation status) but **omit** full cell content.
    *   Agents receive immediate confirmation of success and valid addressing info without redundant token usage.
    *   Full content is retrieved only via explicit `scratch_read`.

### Implementation Steps

1.  Update `scratch_create` schema to accept `cells`.
2.  Implement transactional creation in `Storage`.
3.  Refactor response serialization to strip `content` fields for all write operations.
4.  Verify via integration tests that content is persisted but not echoed.

## Phase 11: Validation Coverage & Tooling

**Goal**: Close the remaining coverage gaps in `scratch_notebook/validation.py` and institutionalize coverage tooling so every release run captures precise diagnostics.

### Key Improvements

1.  **Validation Edge-Case Tests**
    *   Expand unit tests to exercise `ValidationResult` mapping for markdown analyzer failures, schema reference fallbacks, and mixed warning/info diagnostics.
    *   Ensure unsupported languages and missing schemas continue to persist cells while producing advisory diagnostics.
2.  **Integration Verification of Advisory Semantics**
    *   Add integration coverage that triggers unresolved schema references and unsupported languages through MCP flows, asserting responses surface warnings and keep writes intact.
    *   Capture regression fixtures so future changes cannot regress advisory behavior.
3.  **Coverage Workflow & Tooling**
    *   Pin the `coverage` package inside the `dev` optional dependency set and document the standard `coverage run -m pytest` / `coverage report -m` workflow in `DEVELOPMENT.md`, `README.md`, and the release checklist to avoid ad hoc installs.
    *   Update documentation to describe how to interpret coverage gaps, insist on recording them in `implementation.md`, and mandate new tasks whenever advisory-validation branches lose coverage.

### Testing Strategy

*   Leverage existing unit modules (`tests/unit/test_validation_json_yaml.py`, `tests/unit/test_validation_code_markdown.py`, `tests/unit/test_validation_fallbacks.py`) plus `tests/integration/test_mcp_scratch_validate.py` for end-to-end confirmation.
*   Record target coverage thresholds in the implementation log once the work lands so future runs can flag regressions early.
