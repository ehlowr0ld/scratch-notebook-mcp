# Feature Specification: Scratch Notebook MCP

**Feature Branch**: `001-scratch-notebook-mcp`
**Created**: 2025-11-16
**Status**: Draft
**Input**: User description: "Scratch Notebook MCP. See the initial specification and trechnical research document at @scratch-notepad-tool.md and do not diverge from the technical specification developed during the brainstorming session documented within that document."

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Capture Structured Scratch Notes (Priority: P1)

As a developer or AI agent integrating with the MCP ecosystem, I want to create and update scratch notebooks made of multiple cells (text, markdown, code, JSON, YAML) so that I can iteratively capture and refine structured ideas without touching real project files.

**Why this priority**: This is the core value of the Scratch Notebook MCP server: providing a safe, persistent scratch workspace that supports multi-cell structured content for exploratory work and planning.

**Independent Test**: Create a new scratch notebook, append multiple cells of different languages (for example markdown and JSON), update one cell, and confirm that reads always return the expected cells and content without affecting any non-scratch files.

**Acceptance Scenarios**:

1. **Given** a client with access to the Scratch Notebook MCP server, **When** they create a new scratch notebook entry with a chosen identifier that does not already exist, **Then** the notebook entry is created with zero cells and can be retrieved later by that identifier, and creation MUST fail with a clear error if the identifier is already in use (unless an explicit force/reset operation is requested).
2. **Given** an existing scratch notebook entry, **When** the client appends a new cell with specified language and content, **Then** the notebook entry includes the new cell at the end with a stable index and the content is returned unchanged on subsequent reads.
3. **Given** an existing scratch notebook entry with multiple cells, **When** the client replaces the content of a specific cell index, **Then** only that cell is updated and all other cells remain unchanged.

---

### User Story 2 - Validate Scratch Content Early (Priority: P2)

As a developer or AI agent drafting structured content in scratch cells, I want to validate JSON, YAML, code, and markdown cells so that I can catch syntax and schema issues early before moving the content into production files or external systems.

**Why this priority**: Early validation reduces errors when structured scratch content is later copied into real configurations, APIs, or documentation, and aligns directly with the technical validation behaviors defined in the existing specification.

**Independent Test**: Create a scratch notebook with cells in different languages, mark some cells for validation, run validation, and confirm that valid cells pass while invalid cells report clear errors and warnings without crashing the server.

**Acceptance Scenarios**:

1. **Given** a scratch notebook with a JSON cell that contains valid JSON and an optional matching JSON Schema, **When** the client requests validation for that cell, **Then** the result indicates the cell is valid and reports no errors.
2. **Given** a scratch notebook with a YAML cell that is syntactically invalid, **When** the client requests validation for that cell, **Then** the result indicates the cell is invalid and includes at least one human-readable error message pointing to the issue.
3. **Given** a scratch notebook with one or more code cells in supported languages, **When** the client requests validation for those cells, **Then** syntax errors are reported with language, line, and column information where available, and syntactically correct cells are reported as valid.
4. **Given** a scratch notebook with markdown and plain text cells, **When** the client requests validation, **Then** markdown analysis results are provided (for example structural or style warnings) and plain text cells are treated as valid without structural errors.
5. **Given** a scratch notebook whose metadata defines reusable JSON Schemas and multiple JSON/YAML cells referencing those schemas, **When** the client requests validation, **Then** each referenced schema is resolved from the notebook metadata, applied to every referencing cell, and the results clearly indicate when a shared schema passes or fails without requiring inline duplication.
6. **Given** a scratch notebook that stores shared schemas in metadata, **When** a client lists schemas or fetches a specific schema, **Then** each schema entry includes its UUID identifier, human-readable description, and JSON Schema payload, and updates to a schema entry are immediately reflected in subsequent validation requests.

---

### User Story 3 - Discover and Navigate Scratch Notebooks (Priority: P3)

As a developer or AI agent working with multiple scratch notebooks, I want to list available notebook entries and inspect their cells (with ids and descriptions) so that I can quickly find, reuse, or clean up scratch content during longer sessions.

**Why this priority**: Listing and inspecting scratch entries and their cells makes the scratch system manageable at scale, allowing users and agents to locate the right scratchpad without remembering exact identifiers.

**Independent Test**: Create multiple scratch notebook entries, add descriptive metadata and cells, invoke listing and read operations, and confirm that identifiers, descriptions, and cell information are returned in a way that supports visual search and navigation.

**Acceptance Scenarios**:

1. **Given** several existing scratch notebook entries, **When** the client requests a list of scratch notebooks, **Then** the response includes each notebook id and a human-readable description or metadata field suitable for visual identification.
2. **Given** a specific scratch notebook entry with multiple cells, **When** the client inspects that notebook, **Then** the response includes each cell's index, language, and an optional short description or metadata that helps users understand the cell's purpose at a glance.
3. **Given** an outdated or no-longer-needed scratch notebook entry, **When** the client requests deletion of that entry, **Then** the notebook and all its cells are removed from subsequent list and read operations while leaving other entries unaffected.

---

### User Story 4 - Organize and Search Scratchpads (Priority: P2)
- As an operator or AI agent managing many scratchpads, I want to group scratchpads into namespaces and apply tags so that I can filter listings and target related cells quickly.
- I also want to run semantic search across all scratchpads for a tenant so that I can retrieve relevant cells even when I do not remember exact identifiers.

**Why this priority**: Namespaces and tags provide the organizational layer necessary once scratchpads scale beyond a handful. Semantic search builds on that structure to surface relevant information efficiently without manual scanning.

**Independent Test**: Create multiple scratchpads across namespaces with overlapping tags, assign distinct tags to cells, and run list/read/search operations while varying namespace and tag filters. Confirm that responses include only the requested subset, that aggregated cell tags are surfaced, and that semantic search returns expected matches ordered by similarity.

**Acceptance Scenarios**:

1. **Given** two namespaces (for example `planning` and `design`) each containing scratchpads, **When** a client lists scratchpads with `namespaces=["planning"]`, **Then** only scratchpads assigned to the `planning` namespace are returned, and listing with no filter returns both namespaces.
2. **Given** a scratchpad with tags `["ml", "release"]` and cells tagged with `["model"]` and `["deployment"]`, **When** the client reads the scratchpad with `tags=["model"]`, **Then** only the cells tagged `model` are returned while the response metadata still includes the scratchpad tags and a synthesized `cell_tags` array aggregating all cell tag values.
3. **Given** multiple scratchpads under the same tenant, **When** the client invokes semantic search with a natural language query and optional `namespaces` and `tags` filters, **Then** the server returns ranked hits containing the scratchpad id, cell id, similarity score, and matching snippet only for scratchpads that satisfy the supplied filters.
4. **Given** an existing deployment without auth enabled, **When** an operator enables auth and provides a tenant token list, **Then** the server migrates all scratchpads from the implicit default tenant to the first configured tenant, records the migration in logs, and subsequent namespace/list/search operations are scoped to that tenant.

---

### Edge Cases

- What happens when a client attempts to read, validate, or delete a scratch notebook entry that does not exist? The system must return a clear, non-ambiguous error without creating or mutating any scratchpads.
- How does the system handle requests to access or modify a cell index that is out of range for the given scratch notebook entry? The system must respond with a clear error indicating the invalid index and must not change any existing cells.
- What happens when validation is requested for a cell with a language that does not support validation (for example plain text) or when validation tools are temporarily unavailable? The system must degrade gracefully, returning a safe result indicating that validation was not performed rather than failing unexpectedly.
- How does the system behave if the same scratch notebook identifier is reused in parallel sessions or rapid repeated calls? The system must maintain consistent, predictable ordering and indexing for cells without data loss or duplication.

## Clarifications

### Session 2025-11-16

- Q: What storage and capacity limits and eviction behavior should the scratch notebook server enforce? → A: Configurable maximum number of scratchpads with 0 meaning unlimited, default 1024, and a configurable eviction policy with modes discard (default) or fail; discard may evict existing scratchpads to honor the limit and MUST report which entries were discarded in the creation response, while fail mode does not evict and instead returns an explicit error when the limit is reached.
- Q: What happens if `scratch_create` is invoked for an identifier that already exists? → A: Creation MUST fail with a clear `INVALID_ID` (or equivalent) error unless the request explicitly opts into a force/reset mode; the server MUST NEVER overwrite existing scratchpads silently.
- Q: In discard mode, which scratchpads should be evicted when capacity is exceeded? → A: Evict the least recently used scratchpad based on last read/write access time, breaking ties by oldest creation time.
- Q: What durability guarantee should successful scratchpad mutations have across crashes and restarts? → A: Operations that return ok MUST be durably persisted to the configured storage directory so that their effects survive normal process restarts, favoring consistency over single-digit millisecond latency; catastrophic OS or disk failures remain out of scope.
- Q: How should stdio, HTTP, and SSE transports and their configuration behave? → A: The server MUST support the standard MCP transports: stdio MCP and the HTTP+SSE MCP transport. For HTTP+SSE, HTTP POST carries MCP requests and SSE carries the MCP event stream as defined by MCP and `fastmcp` (for example streaming tool outputs or MCP-level notifications), not a separate ad hoc application event API. By default (when no HTTP/SSE config is provided) HTTP and SSE are both enabled on 127.0.0.1 at a shared high, non-reserved port with distinct paths (for example `/http` and `/sse`). An optional Unix domain socket may be configured in addition to the TCP listener, and the same URIs are used for HTTP and SSE over both interfaces; HTTP and SSE paths MUST NOT collide.
- Q: What concurrency semantics should apply when multiple clients interact with the same scratch notebook entry? → A: Per-scratchpad operations MUST be applied atomically as all-or-nothing units, and the effective behavior is last-writer-wins in arrival order; the API does not require explicit version tokens or ETags, and correct implementations can use per-scratchpad locking to serialize mutations while still allowing concurrent access to different scratchpads.
- Q: What observability behavior should the server provide? → A: The server MUST emit structured logs for errors, failed validations, and eviction events to stdout and/or stderr only, leaving log collection and persistence to the operator. A dedicated metrics or observability endpoint is optional; if implemented, it SHOULD expose a basic snapshot of counters (for example total operations, total errors, total validations, total evictions) and uptime, using a Prometheus-compatible exposition format at `/metrics` when exposed over HTTP.
- Q: How should a preemptive eviction policy behave? → A: A `preempt` policy enables a background sweeper that periodically deletes scratchpads whose last access time is older than a configurable `preempt_age`. The age MUST be specified as a string with an integer value and optional unit suffix (for example `24h`, `30m`, `600s`); supported suffixes are `h` for hours, `m` for minutes, and `s` for seconds, and if no suffix is provided the value MUST be interpreted in hours. The sweeper runs regardless of current capacity, and capacity-related limits (such as `max_scratchpads`) continue to apply as defined elsewhere in this spec.
- Q: What security and tenancy model should apply, and how should authentication work for HTTP/SSE? → A: The server MUST be safe to run in multi-tenant scenarios. By default, when bound only to `127.0.0.1`, it MAY operate without explicit auth as a single-user local tool. For remote or shared deployments, HTTP/SSE endpoints SHOULD support an optional authentication mechanism (for example an `Authorization: Bearer <token>` header), and each scratchpad MUST be associated with an authenticated principal when auth is enabled. All operations MUST enforce that only the owning principal can access or mutate a scratchpad, and the server MUST NOT reveal the existence of other principals' scratchpads solely based on guessed UUIDs.
- Q: What default size and count limits should protect against runaway usage while not constraining normal clients? → A: The server SHOULD expose configurable limits for the maximum number of cells per notebook and the maximum size of a single cell in bytes (for example defaults of 1024 cells per notebook and 1 MiB per cell), with `0` meaning unlimited for each. When a limit is exceeded, the server MUST reject the offending operation with a clear error rather than partially applying it.
- Q: How should validation request timeouts be handled? → A: The server SHOULD support a configurable overall timeout for `scratch-validate` requests (for example `validation_request_timeout`). If a validation request exceeds this timeout, the server MUST fail the entire request with a timeout error (for example code `VALIDATION_TIMEOUT`) and MUST NOT return partial per-cell results.
- Q: How often should the preemptive sweeper run and how should its interval be configured? → A: The `preempt` sweeper SHOULD run at a configurable interval (for example `preempt_interval`), defaulting to once every 10 minutes. The interval MUST use the same integer-plus-suffix time format as `preempt_age`, and implementors SHOULD choose a reasonable minimum interval to avoid excessive resource usage.
- Q: If a metrics endpoint is exposed, where should it live and in what format? → A: If an observability endpoint is implemented, it SHOULD be exposed on the existing HTTP listener at the `/metrics` path and SHOULD use the Prometheus text exposition format, exposing at least basic counters and uptime as described in the observability NFR.
- Q: How should error codes be defined and managed? → A: All error responses and logged error events MUST include a stable machine-readable `code` and a human-readable `message`. Implementations MUST define the error codes in a single module or file as constants (each with a brief comment), and reference those constants from call sites. At minimum, the implementation SHOULD define codes such as `NOT_FOUND`, `INVALID_ID`, `INVALID_INDEX`, `CAPACITY_LIMIT_REACHED`, `VALIDATION_ERROR`, `VALIDATION_TIMEOUT`, `CONFIG_ERROR`, and `INTERNAL_ERROR`.
- Q: When do configuration changes take effect? → A: Configuration from command-line arguments, environment variables, and the optional config file MUST be evaluated at server startup only. Changes take effect only after a restart; the server is not required to support hot reloading of configuration.
- Q: How should graceful shutdown behave? → A: On shutdown, the server MUST stop accepting new connections and operations, return a clear error to new requests, and wait up to a configurable `shutdown_timeout` (default 5 seconds) for in-flight operations to complete. After this timeout, any remaining operations MAY be aborted to allow the process to exit.
- Q: How should configuration and auth token files be provisioned? → A: When a config or auth token file path is provided, the server MUST create the containing directories if they do not yet exist and MUST create the files themselves if they are missing, populating them with the effective configuration or token map computed from defaults plus CLI/environment overrides. Operators can subsequently remove CLI overrides and rely on the generated files. When no file paths are supplied, the server MUST NOT assume defaults or emit files; it runs purely from defaults and CLI/environment overrides.
- Q: How should multiple auth tokens be provided? → A: The CLI MUST accept repeated `--auth-token principal:token` style options (short form TBD) so that operators can register more than one tenant without using JSON. These entries merge with any tokens loaded from an optional auth token file, with CLI arguments taking precedence.
- Q: How are namespaces represented and managed? → A: Each scratchpad carries a `namespace` string (case-sensitive) that is unique per tenant. Namespaces are not modeled as separate documents; instead, the server maintains a namespace registry derived from stored scratchpads so clients can list available namespaces, create new namespace strings, rename existing namespaces, or delete them explicitly. Deleting a namespace fails if scratchpads still reference it unless `delete_scratchpads: true` is provided, in which case those scratchpads are deleted transactionally.
- Q: How do tags interact with scratchpads and cells? → A: Scratchpads expose a `tags` string array representing labels applied at the pad level. Each cell also supports its own `tags` array. When reading a scratchpad, the server returns both the explicitly stored `tags` and a synthesized `cell_tags` array that is the union of all tags assigned to cells; this synthesized array is not persisted to avoid drift. Listing, reading, and semantic search operations accept optional `tags` filters that match when any supplied tag is present.
- Q: What storage technology and durability guarantees apply? → A: The implementation MUST persist all scratchpads, cells, schemas, namespaces, and embeddings in LanceDB tables located under the configured storage directory. No auxiliary JSON files are used. Successful mutations MUST commit through LanceDB so data survives restarts without requiring the process to keep a full in-memory copy.
- Q: How does semantic search operate? → A: The server maintains vector embeddings for cells (and optionally scratchpad summaries) using the `sentence-transformers/all-MiniLM-L6-v2` model. Semantic search queries generate an embedding for the query string, perform a nearest-neighbor lookup in LanceDB, and return ranked matches. Filters on namespaces and tags are applied during the query so only matching scratchpads are considered.
- Q: What happens when auth is enabled after running without tenants? → A: On first startup with an auth configuration, if existing scratchpads belong to the implicit default tenant, the server reassigns them to the first tenant defined via CLI or auth file, emits a structured log describing the migration, and documents the behavior in operator guidance. Subsequent startups treat the explicit tenant id as authoritative.
- Q: Which metadata fields are canonical and how are they exposed? → A: Scratchpads accept optional `title`, `description`, and `summary` fields inside `metadata`. These fields are explicitly documented in tool schemas so clients see them in prompts, and they are included in list/read responses as top-level properties for easy consumption. Any other metadata keys remain opaque.
- Q: How can clients retrieve all namespaces and tags in use? → A: `scratch_namespace_list` returns every namespace for the tenant (even if no scratchpads currently reference it). A dedicated `scratch_list_tags` tool returns two deduplicated arrays: tags applied directly to scratchpads and tags present on any cells.

## Requirements *(mandatory)*

This section describes behavior in business terms. All low-level schemas, field definitions, and validation rules are defined in the authoritative technical specification `specs/scratch-notepad-tool.md`, and this feature spec MUST NOT contradict that document. Where this document adds behavior (for example persistence configuration or id formats), those behaviors MUST remain consistent with the data models and MCP tool contracts described in `specs/scratch-notepad-tool.md`.

### Functional Requirements

- **FR-001**: The system MUST allow clients to create scratch notebook entries identified by a caller-chosen or server-generated scratch id and optional metadata, and to retrieve those entries by id in subsequent calls. Notebook creation MUST support both creating an empty notebook (with no cells) and creating a notebook pre-populated with one or more cell definitions. Creation MUST NEVER overwrite an existing scratchpad silently; if the requested `scratch_id` already exists, the server MUST return a clear error (for example `INVALID_ID`) unless an explicitly documented force/reset mode is invoked. Resets or edits MUST use dedicated non-create operations.

- **FR-002**: The system MUST support managing an ordered list of cells within each scratch notebook entry, including appending new cells, replacing existing cells at a given index, and deleting entire scratch notebook entries. All cell-management behaviors MUST follow the data models and validation semantics defined in `specs/scratch-notepad-tool.md`, and the system MAY expose convenience operations that bundle multiple low-level steps (for example, creating a notebook and several cells in one call) as long as they do not change the underlying semantics of the underlying tools and schemas.

- **FR-003**: The system MUST support cells with different content types (including at least code, JSON, YAML, markdown, and plain text) and record for each cell at least its stable cell id, its index within the notebook, its language or format, and its raw content.

- **FR-004**: The system MUST provide a way to list existing scratch notebook entries, returning a mapping of scratch notebook ids to human-readable descriptions or metadata fields to support quick identification and visual search. This aligns with the requirement that each scratch notebook entry has an id and description.

- **FR-005**: The system MUST provide a way to inspect a single scratch notebook entry and see all of its cells, including each cell's id, index, language, and any descriptive metadata that helps users understand the cell's role. This aligns with the requirement that each cell has an id and description within the scratch notebook entry.
- **FR-005A (Filtered Scratch Read)**: The `scratch_read` tool MUST accept an optional list of cell identifiers or indices and return only the matching subset. It MUST also expose a parameter controlling whether scratchpad metadata is included in the response, defaulting to current behavior.

- **FR-006**: The system MUST support validating scratch cells on demand, including at least JSON, YAML, markdown, and supported programming languages, and MUST return structured validation results indicating per-cell validity, errors, warnings, and basic details (such as language and cell index), consistent with the `scratch-validate` response schema defined in `specs/scratch-notepad-tool.md`.

- **FR-007**: For structured data cells (JSON and YAML), when a JSON Schema is attached to a cell, the system MUST apply both syntax and schema validation and indicate in the result whether schema validation was performed and whether it passed. Cells MAY reference shared schemas defined in the owning scratchpad's metadata (for example `scratchpad.metadata.schemas`). Each shared schema entry MUST be a mapping that includes: `id` (UUID string), `description` (string), and `schema` (the JSON Schema definition). The system MUST resolve `$ref` values that target those shared schemas using a documented URI format (for example `scratchpad://schemas/<id>`). Inline schemas MUST continue to be supported alongside shared references.
- **FR-007A (Schema Definition Validation)**: The server MUST validate that any schema supplied inline or via scratchpad metadata is valid JSON and a syntactically valid JSON Schema before accepting it. Invalid definitions MUST result in `VALIDATION_ERROR` without mutating the scratchpad or schema registry.

- **FR-008**: For code cells in supported languages, the system MUST surface syntax diagnostics (errors and, where available, line and column information) rather than failing silently or returning generic error messages, using the underlying syntax-checking behavior described in `specs/scratch-notepad-tool.md`.

- **FR-009**: For markdown cells, the system MUST provide analysis output that can highlight structural or style issues, and for plain text cells the system MUST treat them as valid without structural validation while still returning a consistent validation result shape.

- **FR-010**: The system MUST avoid mutating or creating scratch notebooks when operations fail (for example invalid ids, invalid indices, or validation errors), and MUST always return clear error information in those cases.

- **FR-011 (Persistence Directory)**: On server launch, the scratch notebook server MUST accept a storage directory parameter that designates the root for all persisted scratchpad data. If the parameter is omitted, the server MUST default to a `scratch-notebook` subdirectory beneath the current working directory used to start the process. Whether the directory comes from the default or user input, the server MUST create it (including any required parent directories) before writing data or fail fast with a clear error. All persisted scratchpads, cells, namespaces, schema registries, embeddings, and auxiliary indices MUST live inside that directory. Clients interact only via logical ids; storage details remain internal.

- **FR-012 (Explicit Deletion Semantics)**: Deletion of an entire scratch notebook entry MUST occur only via an explicit delete-scratchpad operation that takes the scratchpad id as an argument. The server MUST NOT silently or automatically delete scratchpads as a side effect of other operations. Any optional retention or cleanup policy MUST be explicit in configuration and MUST NOT contradict the explicit delete operation.

- **FR-013 (Id Format and Uniqueness)**: All scratch notebook ids and cell ids MUST be UUIDs (for example UUIDv4), treated as opaque identifiers by clients. When the server generates a new id, it MUST ensure uniqueness not only statistically (by using UUIDs) but also by checking the storage backend (for example, verifying that no existing scratchpad or cell with that id is already persisted). In the extremely unlikely case of a collision, the server MUST generate a new UUID before persisting. Clients MUST be able to rely on ids being globally unique within the scope of the storage directory.

- **FR-014 (Backend-Agnostic API)**: The scratch notebook MCP API MUST expose only logical ids and structured content; it MUST NOT expose internal filesystem paths or storage details to clients. The server implementation MAY change its physical storage strategy (for example from flat files to a database) as long as the persistence, identity, and validation behaviors defined in this spec and in `specs/scratch-notepad-tool.md` remain unchanged from the client perspective.

- **FR-015 (Python Package And CLI Entry Point)**: The Scratch Notebook MCP server MUST be delivered as a pip-installable Python package (for example `scratch-notebook`) that can be launched both as a module (`python -m scratch_notebook`) and via a console script entry point (for example `scratch-notebook`). The CLI MUST expose configuration options consistent with this spec (including at least storage directory, transports, capacity and eviction policy, timeouts, and auth-related settings), and these parameters MUST map directly to the configuration model described in the Non-Functional Requirements.

- **FR-016 (Auth Token Registry Management)**: When authentication is enabled, the CLI MUST accept repeated auth-token arguments in the form `--auth-token principal:token`, allowing multiple tenants to be defined without JSON. These CLI-provided tokens MUST merge with (and override) entries loaded from an optional auth token file. The merge is additive (the union of file and CLI entries), and when both define the same token or principal, the CLI-provided value takes precedence. The server MUST create the auth token file and parent directories if a path is provided but no file exists, writing the merged token registry (defaults plus CLI/env overrides). When no auth token file path is provided, the server MUST rely solely on defaults and CLI/env overrides and MUST NOT write an implicit file.
- **FR-017 (Schema Registry Management)**: The system MUST expose MCP tools to manage shared schemas per scratchpad, including listing schemas for a scratchpad, retrieving a schema by scratchpad id and schema UUID, and creating or updating schema entries. Each schema entry MUST include `id`, `description`, and `schema`, and the server MUST validate payloads per FR-007A before persisting changes. Schema management tools MUST follow tenant scoping rules.
- **FR-018 (Cell Listing Tool)**: The system MUST expose an MCP tool that lists cells for a scratchpad, returning entries with `index`, `cell_id`, `language`, optional description metadata, and lightweight content indicators. The tool MUST support pagination or filtering primitives if the scratchpad exceeds documented limits.
- **FR-019 (Namespace Management)**: Every scratchpad MUST include a `namespace` string scoped to the owning tenant. The server MUST expose MCP tools for listing available namespaces, creating a namespace string (making it selectable even before scratchpads exist), renaming an existing namespace, and deleting a namespace. Namespace names MUST be unique per tenant. Deleting a namespace without `delete_scratchpads: true` MUST fail if scratchpads still reference it; when `delete_scratchpads: true` is provided, the server MUST delete the namespace and all referencing scratchpads in a single transaction.
- **FR-020 (Tags and Aggregation)**: Scratchpads MUST store a `tags` array of strings. Cells MUST store their own `tags` array. The `scratch_read` response MUST always include the persisted scratchpad `tags` and a synthesized `cell_tags` array that is the union of all cell tag values (the synthesized array MUST NOT be persisted). Listing, reading, and semantic search operations MUST accept an optional `tags` array that matches when any requested tag is present on the scratchpad or on any of its cells.
- **FR-021 (Filtered Listings and Reads)**: `scratch_list` MUST accept optional `namespaces` and `tags` filters and return only scratchpads matching the supplied namespace set and tag criteria. `scratch_read` and `scratch_list_cells` MUST accept optional `namespaces`, `tags`, and `cell_ids` parameters; when both `cell_ids` and `tags` are provided, the result MUST include only the intersection (cells whose id is requested and that contain at least one requested tag). Metadata toggles from FR-005A remain in effect.
- **FR-022 (Semantic Search Tool)**: The server MUST expose a `scratch_search` MCP tool that accepts a tenant-scoped natural language `query`, optional `namespaces`, optional `tags`, and optional `limit`. Results MUST include the scratchpad id, cell id (or scratchpad-level hit), similarity score, matched namespace, matched tags, and a short snippet. The server MUST use the `sentence-transformers/all-MiniLM-L6-v2` embedding model by default and MUST document how operators can override the embedder. Vector searches MUST honor namespace and tag filters.
- **FR-023 (Tenant Migration Behavior)**: When authentication is enabled for the first time in a deployment that previously ran without auth, the server MUST detect scratchpads owned by the implicit default tenant, reassign them to the first tenant defined by the new configuration (CLI takes precedence over auth file order), emit a structured log describing the reassignment, and provide an operator-facing guide describing the migration semantics. The migration MUST occur exactly once per deployment.

- **FR-024 (Canonical Metadata Exposure)**: Scratchpad metadata MUST support the canonical fields `title`, `description`, and optional `summary`. `scratch_create` requests MUST surface input slots for all three fields so agents can supply them deliberately. `scratch_read` responses MUST include all canonical fields by default and MUST offer an `include_metadata` toggle that allows callers to omit metadata entirely when they only need cell payloads. `scratch_list` responses MUST default to a lean payload containing only `scratch_id`, `title`, `description`, and `cell_count`, allowing agents to choose a notebook without incurring unnecessary token cost; the `summary` field MUST be retrievable via `scratch_read` (or other detailed views) but MUST NOT be included in the default list response. Tool prompts and official documentation MUST explain the intended usage and detail level for each canonical field.
- **FR-025 (Tag Listing Tool)**: The server MUST expose an MCP tool that returns the deduplicated set of tags applied directly to scratchpads and the deduplicated set of tags applied to cells. The response MUST include separate arrays (`scratchpad_tags`, `cell_tags`) and MUST respect tenant scoping.

### Key Entities *(include if feature involves data)*

- **Scratch Notebook Entry**: Represents a logical scratchpad identified by a scratch notebook id (a UUID string), containing an ordered list of cells and optional metadata (for example title, description, tags). It is independent of any real project files and is intended purely for exploratory and planning work. A Scratch Notebook Entry MAY be created empty or with an initial set of cell definitions, as defined in the technical specification. For listing, each scratch notebook entry MUST expose its id and a human-readable description or metadata that supports quick identification.

- **Scratch Cell**: Represents a single unit of content within a scratch notebook entry, with fields such as:
  - a stable cell id (a UUID string),
  - index (position in the notebook),
  - language or format (for example json, yaml, md, py),
  - raw content,
  - an optional flag indicating whether to validate automatically,
  - optional JSON Schema for structured formats,
  - and optional descriptive metadata.
  Each cell MUST be addressable both by its index within the notebook and by its cell id when returned in list or read responses, to support robust client-side referencing.
  - `tags: string[]` (optional)
    - Cell-level labels used for fine-grained filtering and semantic aggregation; duplicates are ignored when computing scratchpad-level `cell_tags`.

- **Validation Result**: Represents the outcome of validating a single cell, including the cell index, language, overall valid or invalid flag, lists of errors and warnings (each with message and optional location details), and a structured details object summarizing syntax, schema, or analysis checks. Validation Result objects MUST conform to the `ValidationResult` schema defined in `specs/scratch-notepad-tool.md` and MUST be returned as an array in the `scratch-validate` response, keyed by scratch notebook id.

## Schema Catalogue (Authoritative References)

All JSON Schemas are defined in `specs/scratch-notepad-tool.md`. The tables below enumerate every schema used by this feature and reference the exact section and `$id` so there are no implicit or missing definitions.

**Core entity schemas**

| Logical object | JSON Schema `$id` | Definition |
| --- | --- | --- |
| `ScratchCell` | `https://example.com/scratch-notebook/schemas/scratch-cell-v2.json` | `specs/scratch-notepad-tool.md` §1.1 |
| `Scratchpad` | `https://example.com/scratch-notebook/schemas/scratchpad-v2.json` | `specs/scratch-notepad-tool.md` §1.2 |
| `ErrorResult` | `https://example.com/scratch-notebook/schemas/error-result.json` | `specs/scratch-notepad-tool.md` §1.3 |
| `ValidationResult` | `https://example.com/scratch-notebook/schemas/validation-result.json` | `specs/scratch-notepad-tool.md` §1.4 |

**Tool request/response schemas**

| Tool | Request schema `$id` | Response schema `$id` | Definition |
| --- | --- | --- | --- |
| `scratch_create` | `https://example.com/scratch-notebook/schemas/scratch-create-request.json` | `https://example.com/scratch-notebook/schemas/scratch-create-response.json` | `specs/scratch-notepad-tool.md` §2.1 |
| `scratch_read` | `https://example.com/scratch-notebook/schemas/scratch-read-request.json` | `https://example.com/scratch-notebook/schemas/scratch-read-response.json` | `specs/scratch-notepad-tool.md` §2.2 |
| `scratch_append_cell` | `https://example.com/scratch-notebook/schemas/scratch-append-cell-request.json` | `https://example.com/scratch-notebook/schemas/scratch-append-cell-response.json` | `specs/scratch-notepad-tool.md` §2.3 |
| `scratch_replace_cell` | `https://example.com/scratch-notebook/schemas/scratch-replace-cell-request.json` | `https://example.com/scratch-notebook/schemas/scratch-replace-cell-response.json` | `specs/scratch-notepad-tool.md` §2.4 |
| `scratch_delete` | `https://example.com/scratch-notebook/schemas/scratch-delete-request.json` | `https://example.com/scratch-notebook/schemas/scratch-delete-response.json` | `specs/scratch-notepad-tool.md` §2.5 |
| `scratch_list` | `https://example.com/scratch-notebook/schemas/scratch-list-request.json` | `https://example.com/scratch-notebook/schemas/scratch-list-response.json` | `specs/scratch-notepad-tool.md` §2.6 |
| `scratch_validate` | `https://example.com/scratch-notebook/schemas/scratch-validate-request.json` | `https://example.com/scratch-notebook/schemas/scratch-validate-response.json` | `specs/scratch-notepad-tool.md` §2.7 |
| `scratch_list_cells` | `https://example.com/scratch-notebook/schemas/scratch-list-cells-request.json` | `https://example.com/scratch-notebook/schemas/scratch-list-cells-response.json` | `specs/scratch-notepad-tool.md` §2.8 |
| `scratch_list_schemas` | `https://example.com/scratch-notebook/schemas/scratch-list-schemas-request.json` | `https://example.com/scratch-notebook/schemas/scratch-list-schemas-response.json` | `specs/scratch-notepad-tool.md` §2.9 |
| `scratch_get_schema` | `https://example.com/scratch-notebook/schemas/scratch-get-schema-request.json` | `https://example.com/scratch-notebook/schemas/scratch-get-schema-response.json` | `specs/scratch-notepad-tool.md` §2.10 |
| `scratch_upsert_schema` | `https://example.com/scratch-notebook/schemas/scratch-upsert-schema-request.json` | `https://example.com/scratch-notebook/schemas/scratch-upsert-schema-response.json` | `specs/scratch-notepad-tool.md` §2.11 |
| `scratch_namespace_list` | `https://example.com/scratch-notebook/schemas/scratch-namespace-list-request.json` | `https://example.com/scratch-notebook/schemas/scratch-namespace-list-response.json` | `specs/scratch-notepad-tool.md` §2.12 |
| `scratch_namespace_create` | `https://example.com/scratch-notebook/schemas/scratch-namespace-create-request.json` | `https://example.com/scratch-notebook/schemas/scratch-namespace-create-response.json` | `specs/scratch-notepad-tool.md` §2.13 |
| `scratch_namespace_rename` | `https://example.com/scratch-notebook/schemas/scratch-namespace-rename-request.json` | `https://example.com/scratch-notebook/schemas/scratch-namespace-rename-response.json` | `specs/scratch-notepad-tool.md` §2.14 |
| `scratch_namespace_delete` | `https://example.com/scratch-notebook/schemas/scratch-namespace-delete-request.json` | `https://example.com/scratch-notebook/schemas/scratch-namespace-delete-response.json` | `specs/scratch-notepad-tool.md` §2.15 |
| `scratch_search` | `https://example.com/scratch-notebook/schemas/scratch-search-request.json` | `https://example.com/scratch-notebook/schemas/scratch-search-response.json` | `specs/scratch-notepad-tool.md` §2.16 |
| `scratch_list_tags` | `https://example.com/scratch-notebook/schemas/scratch-list-tags-request.json` | `https://example.com/scratch-notebook/schemas/scratch-list-tags-response.json` | `specs/scratch-notepad-tool.md` §2.17 |

### Non-Functional Requirements

- **NFR-001 (Scratchpad Capacity Limit)**: The server MUST support a configurable maximum number of scratch notebook entries (for example via a `max_scratchpads` setting). A value of 0 MUST mean unlimited scratchpads, and the default value SHOULD be 1024. The server is not required to track total storage size; capacity is defined purely in terms of scratchpad count.
- **NFR-002 (Eviction Policy and Limit Reached Behavior)**: When the configured scratchpad capacity limit is reached, behavior MUST be controlled by an explicit eviction policy setting with at least two modes: `discard` (the default) and `fail`, and MAY additionally support a `preempt` mode as described in NFR-010. In `discard` mode, the server MUST evict one or more existing scratchpads using a least-recently-used policy based on last read/write access time (breaking ties by oldest creation time) to make room for a new one, and any creation request that causes eviction MUST include a clear message indicating that eviction occurred and which scratchpads were discarded. That message is surfaced via the `evicted_scratchpads` array in the `scratch_create` response, and the same identifiers MUST be logged. In `fail` mode, the server MUST NOT evict existing scratchpads when the limit is reached and MUST instead fail creation requests with an explicit error indicating that the capacity limit has been reached.
- **NFR-003 (Configuration Source and Persistence)**: Configuration options can be provided via command-line arguments, environment variables, or an optional JSON config file. CLI/env values MUST override file contents, and the merged configuration MUST be evaluated only at startup. When a config file path is supplied but the file does not yet exist, the server MUST create any missing parent directories and write the effective configuration (defaults merged with CLI/env overrides) to that file before continuing. If no config file path is supplied, the server MUST NOT create a default file.
- **NFR-004 (Durability and Crash Recovery)**: For any operation that mutates scratchpad state and returns ok, the server MUST ensure that the resulting state is durably persisted by committing the change to LanceDB under the configured storage directory so that it can be recovered after a normal process restart. Implementations MAY rely on LanceDB's transaction semantics or explicit flushes to achieve this and SHOULD favor correctness and consistency over microsecond or single-digit millisecond latency. Durability in the face of catastrophic OS or disk failures is out of scope.
- **NFR-005 (Transport Support)**: The Scratch Notebook MCP server MUST support stdio MCP and the HTTP+SSE MCP transport as defined by MCP and `fastmcp`. Each transport (stdio, HTTP+SSE) MUST be individually configurable so that it can be enabled or disabled explicitly. If no transport-specific configuration is provided, stdio MUST be enabled and HTTP+SSE MUST both be enabled on a local listener using default host, port, and paths as defined in this spec.
- **NFR-006 (Listener Addressing for HTTP/SSE)**: HTTP and SSE traffic that together implement the MCP HTTP+SSE transport MUST share a single logical HTTP listener configuration consisting of a host, port, and optional Unix domain socket path. By default, the host SHOULD be `127.0.0.1` and the port SHOULD be a high, non-reserved port (for example 8765). If a Unix domain socket is configured, the server MUST listen on both the TCP host/port and the Unix socket simultaneously for HTTP and SSE, using the same URIs on both interfaces.
- **NFR-007 (HTTP and SSE Paths and Collision Avoidance)**: MCP requests over HTTP and the MCP SSE event stream MUST be distinguished by their request paths (for example `/http` for HTTP and `/sse` for SSE) on the shared listener. The default paths SHOULD be `/http` and `/sse` respectively. The configuration system MUST validate that the configured HTTP path and SSE path are not identical. These path semantics apply equally when using TCP and when using a Unix domain socket.
- **NFR-008 (Concurrency Semantics)**: For each scratch notebook entry, create, append, replace, delete, and validate operations MUST be applied atomically as all-or-nothing units. When multiple clients issue operations against the same scratchpad concurrently, the observable behavior from the client perspective MUST be last-writer-wins in arrival or scheduling order, without requiring clients to provide explicit version tokens. Implementations MAY use per-scratchpad locking or equivalent mechanisms to achieve this serialization while still allowing concurrent operations on different scratchpads.
- **NFR-009 (Observability – Logging and Metrics)**: The server MUST emit structured, machine-parsable log entries for errors, failed operations, failed validations, and eviction events to stdout and/or stderr only; it MUST NOT write arbitrary log files or grow persistent logs on disk by default. Operators are responsible for collecting or persisting these streams if needed. A dedicated observability or metrics endpoint is optional and controlled by an `enable_metrics` configuration flag (default `false`); if enabled, it SHOULD expose at least a basic snapshot of counters (such as total operations, total errors, total validations, total evictions) and server uptime, and SHOULD use a Prometheus-compatible text exposition format at the `/metrics` path on the HTTP listener.
- **NFR-010 (Preemptive Eviction Sweeper)**: If a `preempt` eviction policy is supported and enabled, the server MUST run a background sweeper at a configurable interval (for example `preempt_interval`, defaulting to 10 minutes) that deletes scratchpads whose last access time is older than a configured `preempt_age` threshold. The `preempt_age` setting MUST be a string consisting of a positive integer and an optional unit suffix, where `s` denotes seconds, `m` denotes minutes, and `h` denotes hours; if no suffix is provided, the value MUST be interpreted in hours. The `preempt_interval` MUST use the same integer-plus-suffix format, and implementations SHOULD enforce a reasonable minimum interval to avoid excessive resource use. The sweeper operates independently of instantaneous capacity and MAY delete scratchpads even when the current number of scratchpads is below `max_scratchpads`, but it MUST NOT delete scratchpads that are newer than the configured `preempt_age`.
- **NFR-011 (Security and Tenant Isolation)**: The server MUST be safe to run in multi-tenant scenarios. For HTTP and SSE transports, the server SHOULD support an optional authentication mechanism (for example an `Authorization: Bearer <token>` header) and MUST associate each scratch notebook entry with an authenticated principal when auth is enabled. All scratchpad operations MUST enforce that only the owning principal can access or mutate a scratchpad, and the server MUST NOT reveal the existence or contents of other principals' scratchpads solely based on guessed UUIDs. When no auth is configured and listeners are bound only to `127.0.0.1`, the server MAY operate in an implicit single-user mode.
- **NFR-012 (Size and Count Limits)**: The server SHOULD expose configurable limits to protect against runaway usage, including at least a maximum number of cells per notebook (default 1024) and a maximum size of a single cell in bytes (default 5_242_880 bytes, i.e. 5 MiB). A value of `0` for these limits MUST mean unlimited. When a limit is exceeded, the server MUST reject the offending operation with a clear error and MUST NOT partially apply the change.
- **NFR-013 (Validation Request Timeout)**: The server SHOULD support a configurable overall timeout for `scratch-validate` requests (for example `validation_request_timeout`), expressed using the standard time-unit suffix rules. If a validation request exceeds this timeout, the server MUST fail the entire request with a timeout error (for example code `VALIDATION_TIMEOUT`) and MUST NOT return partial per-cell results.
- **NFR-014 (Error Code Taxonomy)**: All error responses and logged error events MUST include a stable machine-readable `code` and a human-readable `message`. Implementations MUST define these error codes in a single module or file as constants, each with a brief explanatory comment, and reference those constants from call sites. At minimum, the implementation SHOULD define codes including (but not limited to) `NOT_FOUND`, `INVALID_ID`, `INVALID_INDEX`, `CAPACITY_LIMIT_REACHED`, `VALIDATION_ERROR`, `VALIDATION_TIMEOUT`, `CONFIG_ERROR`, and `INTERNAL_ERROR`.
- **NFR-015 (Configuration Reload Semantics)**: Configuration from command-line arguments, environment variables, and an optional config file MUST be evaluated at server startup only. Changes to configuration MUST take effect only after the server is restarted; the server is not required to support hot reloading of configuration at runtime.
- **NFR-016 (Graceful Shutdown)**: The server MUST support a configurable `shutdown_timeout` interval (default 5 seconds) controlling graceful shutdown behavior. On shutdown, the server MUST stop accepting new connections and operations, return a clear error to any new requests, and wait up to `shutdown_timeout` for in-flight operations to complete. After this timeout elapses, the server MAY abort any remaining operations to allow the process to exit.
- **NFR-017 (Time Configuration Units)**: All configuration options that represent time intervals or ages (such as `preempt_age`, `preempt_interval`, `validation_request_timeout`, and `shutdown_timeout`) MUST use a common string format consisting of a positive integer and an optional unit suffix, where `s` denotes seconds, `m` denotes minutes, and `h` denotes hours. For each parameter, the default unit when no suffix is provided MUST be clearly documented (for example hours for age-like settings such as `preempt_age`, and seconds for timeout-like settings such as `shutdown_timeout` and `validation_request_timeout`).

- **NFR-018 (Packaging And Distribution)**: The Scratch Notebook MCP server MUST be packaged as a standard Python distribution compatible with current Python packaging practices (for example using `pyproject.toml`), including explicit dependency declarations for `fastmcp`, `jsonschema`, `PyYAML`, `syntax-checker`, `markdown-analysis`, `referencing`, `lancedb`, and `sentence-transformers` (with any runtime prerequisites noted). The package MUST define stable entry points (module and console script) for running the server, include semantic versioning metadata, and be suitable for installation via `pip` or equivalent tools without requiring ad hoc post-install steps.

- **NFR-019 (Embedded Storage Engine)**: The server MUST bundle LanceDB as the embedded storage engine. All CRUD, listing, namespace management, schema registry operations, and semantic search indices MUST operate against LanceDB tables without requiring an external database. Implementations MUST avoid loading the entire dataset into memory; queries SHOULD leverage LanceDB's filtering capabilities directly, with optional caching limited to hot items.
- **NFR-020 (Embedding Pipeline)**: The default semantic search embedding model MUST be `sentence-transformers/all-MiniLM-L6-v2` loaded via `sentence-transformers`. Operators MUST be able to override the model path via configuration, and the system MUST document GPU/CPU requirements and caching behavior. Embedding generation MUST occur asynchronously so it does not block the event loop.
- **NFR-021 (Auth Migration Documentation)**: Operator documentation (for example in `quickstart.md` and release notes) MUST describe the default-tenant-to-configured-tenant migration, the structured log emitted during migration, and operator actions required when enabling auth after running without it. Tests MUST assert that the migration log entry is produced when applicable.
- **NFR-022 (Audience-Specific Documentation)**: Project documentation MUST be segmented by audience. `README.md` targets operators configuring the server inside their MCP client and MUST provide practical, assistant-focused setup guidance (for example how the features help the user’s assistant and which flags to toggle) without internal implementation detail. `DEVELOPMENT.md` targets contributors and MUST capture build, test, and architectural notes. Agent-facing usage guidance (for example canonical metadata tone or parameter annotations) MUST live exclusively inside the FastMCP tool prompts so clients receive self-contained instructions. This documentation split is considered a reusable MCP documentation pattern; any future MCP server derived from this spec SHOULD inherit and restate the same audience-specific guidance so generated specs continue to produce user-friendly operator docs and concise developer references.
- **NFR-023 (Namespace Prompt Guidance)**: Agent-facing tool prompts (in particular `scratch_create`) MUST instruct assistants to select a stable namespace for each project, prefer reusing an existing namespace from `scratch_namespace_list`, and adopt a consistent, human-recognisable prefix strategy so separate projects remain logically isolated even when sharing the default tenant.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: At least 90 percent of basic scratch operations (create, read, append cell, replace cell, delete notebook, list notebooks) complete successfully in under 500 milliseconds under typical development workloads, as measured from the MCP client perspective.
- **SC-002**: In a test suite covering valid and invalid JSON, YAML, markdown, and code cells, 100 percent of intentionally invalid cells are reported as invalid with at least one human-readable error message, and 100 percent of valid cells are reported as valid.
- **SC-003**: In usability tests with developers or AI agents working on multi-step tasks, at least 80 percent report that the scratch notebook functionality helps them manage intermediate structured content more effectively than using ad hoc plain-text notes.
- **SC-004**: In automated integration tests for listing and discovery, 100 percent of created scratch notebooks and their cells can be rediscovered and inspected via list and read operations without mismatches between recorded identifiers, descriptions, and actual content.
- **SC-005**: In semantic search evaluation using curated queries across multiple namespaces and tag combinations, at least 90 percent of expected relevant cells appear in the top 5 results, and no result violates namespace or tag filters.
